#! /usr/bin/env node --harmony

var random = require('./src/util/random_inc');
var stringFitness = require('./src/fitness/string_fitness');

var randomProgram = require('./src/lib/random_program');
var instructions = require('./src/lib/instructions');
var interpreter = require('./src/lib/interpreter');

// Our target output.
var targetOutput = 'Hello world';

// The minimum number of valid programs to generate for each generation.
var minPopulation = 100;

// The number of high scorers to persist across generations.
var numParentsGeneration = 10;

// How many mutations for each program for each generation.
var numMutationsEachGeneration = 10;

var generationCount = 0;

// The current population.
var population = [];

var lastHightestScore = 0;

/**
 * Generates a random population.
 */
function generatePopulation() {
	while(true) {
		if (population.length > minPopulation) {
			break;
		}
		randomProgram(function(value) {
			scoreAndAddToPopulation(value);
		});
	}
}

/**
 * Scores this population and adds it to our population.
 */
function scoreAndAddToPopulation(program) {
	var output = '';
	try {
		output = interpreter(program);
	} catch(e) {}

	if (output.length) {
		process.stdout.write('.');
		var score = stringFitness(output, targetOutput);
		//console.log('Score: ' + score, output);
		if (score < 1) {
			return null;
		}
		var record = [program, score, output];
		population.push(record);
		return record;
	}
	return null;
}

/**
 * Sorts the list and generates a new population with only the members we want to keep.
 */
function pruneLowScores() {
	population = population.sort(function(a, b) {
		return b[1] - a[1];
	});
	population.length = numParentsGeneration;
	// If the score remains the same, try to increase mutation count to avoid reaching a local maximum.
	if (lastHightestScore === population[0][1]) {
		numMutationsEachGeneration++;
	}
	lastHightestScore = population[0][1];
}

function mutateAndFillPopulation() {
	// The index of the current program in population that we are mutating.
	var currentMutationIndex = 0;

	// The number of successful mutations for this parent.
	var currentMutationSuccessCount = 0;

	while(true) {
		if (population.length > minPopulation) {
			break;
		}

		// Go to next parent if we finish one.
		if (currentMutationSuccessCount >= numMutationsEachGeneration) {
			currentMutationIndex++;
			currentMutationSuccessCount = 0;
		}

		var mutation = population[currentMutationIndex][0];
		// Mutate 10 times
		for (var i = 0; i < 10; i++) {
			mutation = mutate(mutation);
		}
		var record = scoreAndAddToPopulation(mutation);
		if (record) {
			currentMutationSuccessCount++;
		}
	}
}

function mutate(program) {
	var decision = Math.random();
	if (decision <= 0.4) {
		// Replace a random instruction.
		var pos = random(0, program.length);
		program = program.substr(0, pos) + instructions.randomInstruction() + program.substr(pos + 1);
	} else if (decision <= 0.8) {
		// Insert a random instruction.
		var pos = random(0, program.length);
		program = program.substr(0, pos) + instructions.randomInstruction() + program.substr(pos);
	} else {
		// Remove a random instruction.
		var pos = random(0, program.length);
		program = program.substr(0, pos) + program.substr(pos + 1);
	}
	return program
}

function runStep() {
	generationCount++;
	pruneLowScores();
	console.log('');
	console.log('Generation ' + generationCount);
	console.log('--------------------------------');
	console.log('Top scores:', population)

	mutateAndFillPopulation();

	runStep();
}

generatePopulation();
runStep();
